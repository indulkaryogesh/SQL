CREATE TABLE  AppleStore_combined AS
SELECT * FROM applestore_description1
UNION ALL
SELECT * FROM applestore_description2
UNION ALL
SELECT * FROM applestore_description3
UNION ALL
SELECT * FROM applestore_description4

***EXPLORATORY DATA ANALYSIS ***

--Check the unique apps in both tables

SELECT COUNT(*) AS UniqueAppIds
FROM AppleStore_combined

SELECT COUNT(*) AS UniqueAppIds
FROM AppleStore

--Check the missing values in the key fields
SELECT COUNT(*) AS missingValues
FROM AppleStore_combined
WHERE track_name IS null OR user_rating IS null or prime_genre IS null

SELECT COUNT(*) AS missingValues
FROM AppleStore
WHERE app_desc IS NULL


--find the number of apps per genre
SELECT prime_genre, COUNT(*) AS NumApps 
FROM AppleStore
GROUP BY prime_genre
ORDER BY NumApps DESC


--GET the overview  of the apps ratings
SELECT MIN(user_rating) AS MinRating
       MAX(user_rating) AS MaxRating
       AVG(user_rating) AS AvgRating
FROM AppleStore

---Get the distribution of App prices

SELECT
    (price / 2) *2 AS PriceBinStart,
    ((price / 2) *2) +2 AS PriceBinEnd,
    COUNT(*) AS NumApps
FROM AppleStore
GROUP BY PriceBinStart
ORDER BY PriceBinStart



 ***** ANALYSIS**
--Determine whether paid apps have higher ratings than free apps

SELECT CASE
            WHEN price > 0 THEN 'Paid'
             ELSE 'Free'
       END AS App_Type,
       avg(user_rating) AS Avg_Rating
FROM AppleStore
GROUP BY App_Type


-Check if apps with more supported languages have higher ratings
SELECT CASE
            WHEN lang_num < 10 THEN '<10 languages
            WHEN lang_num BETWEEN 10 AND 30 THEN '10-30 languages
            ELSE >30 languages
       END AS language_bucket,
       avg(user_rating) AS Avg_Rating
FROM AppleStore
GROUP BY language_bucket
ORDER BY Avg_Rating DESC


--check genre with low ratings

SELECT prime_genre, 
       avg(user_rating) AS Avg_Rating
FROM AppleStore
GROUP BY prime_genre
ORDER BY Avg_Rating ASC
LIMIT 10


--Check if there is correlation between the length of app description and user rating

SELECT CASE 
	WHEN LENGTH(b.app_desc) < 500 THEN 'Short'
	WHEN LENGTH(b.app_desc) BETWEEN 500 AND 1000 THEN 'Medium'
	ELSE 'Long'
	END AS desc_bucket,
	avg(user_rating) AS Avg_Rating
FROM 
	AppleStore AS a
JOIN 
	AppleStore_combined AS b
ON 
	a.id = b.id
GROUP BY desc_bucket
ORDER BY Avg_Rating DESC


--CHECK THE TOP RATED APPS FOR EACH GENRE
SELECT prime_genre,
	track name,
	user_rating
FROM (
	SELECT prime_genre,
	track name,
	user_rating,
	RANK () OVER (PARTITION BY prime_genre ORDER BY user_rating DESC, rating_count_tot DESC) AS rank
	FROM 
	AppleStore 
) 	AS a
WHERE
	a.rank = 1
